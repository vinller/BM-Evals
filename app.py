from flask import Flask, render_template, request, redirect, url_for, session, send_file, jsonify
import os
import json
import random
import uuid
import zipfile
from datetime import datetime
from docx import Document
from docx.shared import Pt
from io import BytesIO

import subprocess
import os

app = Flask(__name__)
app.secret_key = 'supersecretkey'

# Load user data
with open("users.json") as f:
    USERS = json.load(f)

# Load question data
with open("questions_grouped.json") as f:
    QUESTIONS_BY_SECTION = json.load(f)

with open("questions_grouped.json") as f:
    grouped = json.load(f)

def push_to_github():
    try:
        subprocess.run(["git", "config", "--global", "user.email", "you@example.com"])
        subprocess.run(["git", "config", "--global", "user.name", os.environ.get("GH_USERNAME")])
        subprocess.run(["git", "add", "questions_grouped.json"])
        subprocess.run(["git", "commit", "-m", "Auto-update questions from app"])
        subprocess.run(["git", "push", f"https://{os.environ.get('GH_USERNAME')}:{os.environ.get('GH_TOKEN')}@github.com/{os.environ.get('GH_USERNAME')}/BM-Evals.git"])
        print("✅ Successfully pushed to GitHub.")
    except Exception as e:
        print("❌ Git push failed:", e)



# ---- Routes ----
@app.route("/")
def home():
    if "user" in session:
        return redirect("/dashboard")
    return redirect("/login")

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        email = request.form.get("email")
        password = request.form.get("password")
        for user_id, info in USERS.items():
            if info["email"] == email and info["password"] == password:
                session["user"] = info
                return redirect("/dashboard")
        return render_template("login.html", error="Invalid credentials")
    return render_template("login.html")

@app.route("/logout")
def logout():
    session.pop("user", None)
    return redirect("/login")

@app.route("/dashboard")
def dashboard():
    if "user" not in session:
        return redirect("/login")
    return render_template("dashboard.html", user=session["user"])

@app.route("/generate", methods=["GET", "POST"])
def generate():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        count = int(request.form.get("set_count"))
        format_type = request.form.get("filename_format")

        timestamp = datetime.now()
        month_name = timestamp.strftime("%B")
        date_str = timestamp.strftime("%Y-%m-%d")
        year = timestamp.strftime("%Y")

        if format_type == "month":
            prefix = f"{month_name} {year}"
        elif format_type == "term":
            prefix = f"Spring {year}"  # Simplified example
        else:
            prefix = f"{date_str}"

        zip_buffer = BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w') as zipf:
            for i in range(count):
                eval_id = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=6))
                student_doc = generate_doc(eval_id, "Student Copy", session["user"], prefix)
                evaluator_doc = generate_doc(eval_id, "Evaluators Copy", session["user"], prefix, include_answers=True)

                student_name = f"{eval_id} {prefix} Student Copy.docx"
                evaluator_name = f"{eval_id} {prefix} Evaluators Copy.docx"

                student_path = os.path.join("History", student_name)
                evaluator_path = os.path.join("History", evaluator_name)
                student_doc.save(student_path)
                evaluator_doc.save(evaluator_path)

                zipf.write(student_path, arcname=student_name)
                zipf.write(evaluator_path, arcname=evaluator_name)

        zip_buffer.seek(0)
        zip_filename = f"{prefix} {count} Set{'s' if count > 1 else ''}.zip"
        return send_file(zip_buffer, as_attachment=True, download_name=zip_filename)

    return render_template("generate.html", user=session["user"])

def generate_doc(uuid, copy_type, user, prefix, include_answers=False):
    doc = Document()
    doc.add_heading(f"BM Evaluation {'EVALUATORS COPY' if copy_type == 'Evaluators Copy' else ''} {prefix}", 0)
    doc.add_paragraph(f"Name: __________________________\t\tDate: ________________")
    doc.add_paragraph(f"Score: ________/100\nEvaluation ID: {uuid}\nGenerated by {user['first_name']} {user['last_name']}\n")

    # Instructions
    if copy_type == "Student Copy":
        doc.add_paragraph("Instructions:")
        doc.add_paragraph("● This evaluation consists of written questions. Answer clearly and concisely.")
        doc.add_paragraph("● You must complete the written portion without using phones, notes, documents, or external sources.")
        doc.add_paragraph("● Attempt every question. Partial credit is awarded.")
        doc.add_paragraph("● You must score 80% or more to pass.")
    else:
        doc.add_paragraph("Instructions: Use the provided answers to guide grading. Each question is worth 2 points.")

    # Collect up to 10 questions from each section (or all if less than 10)
    random.seed(uuid)
    all_sections = []
    for section, qlist in QUESTIONS_BY_SECTION.items():
        sample_count = min(10, len(qlist))  # Avoid sampling too many
        sampled = random.sample(qlist, sample_count)
        all_sections.append({"section": section, "questions": sampled})

    # Add each section and its questions to the document
    q_number = 1
    for s in all_sections:
        doc.add_paragraph(f"\n{s['section']}", style="Heading 2")
        for q in s["questions"]:
            p = doc.add_paragraph()
            p.add_run(f"Q{q_number}. {q['q']}\n").bold = True
            if copy_type == "Student Copy":
                doc.add_paragraph("\n\n\n\n")
            elif include_answers:
                doc.add_paragraph(f"Answer: {q['a']}\n")
            q_number += 1

    return doc

@app.route("/lookup", methods=["GET", "POST"])
def lookup():
    if "user" not in session:
        return redirect("/")

    files = []
    if request.method == "POST":
        uuid = request.form.get("uuid")
        if uuid:
            for filename in os.listdir("History"):
                if uuid.upper() in filename.upper():
                    files.append(filename)
    return render_template("lookup.html", user=session["user"], files=files)

QUESTIONS_FILE = "questions_grouped.json"

@app.route("/questions")
def question_bank():
    if "user" not in session:
        return redirect("/login")
    return render_template("questions.html", user=session["user"])

@app.route("/questions/section_<int:section_num>")
def view_section(section_num):
    if "user" not in session:
        return redirect("/login")

    with open(QUESTIONS_FILE) as f:
        grouped = json.load(f)

    section_keys = list(grouped.keys())
    section_key = section_keys[section_num - 1]
    questions = grouped[section_key]

    return render_template("section_questions.html", section_num=section_num, questions=questions, section_name=section_key, user=session["user"])

@app.route("/questions/section_<int:section_num>/delete", methods=["POST"])
def delete_questions(section_num):
    to_delete = request.json.get("questions", [])

    with open(QUESTIONS_FILE) as f:
        grouped = json.load(f)

    section_keys = list(grouped.keys())
    section_key = section_keys[section_num - 1]
    grouped[section_key] = [q for q in grouped[section_key] if q["q"] not in to_delete]

    with open(QUESTIONS_FILE, "w") as f:
        json.dump(grouped, f, indent=2)

        push_to_github()

    return jsonify({"status": "success"})

@app.route("/questions/section_<int:section_num>/add", methods=["POST"])
def add_question(section_num):
    data = request.json
    new_q = {"q": data["q"], "a": data["a"]}

    with open(QUESTIONS_FILE) as f:
        grouped = json.load(f)

    section_keys = list(grouped.keys())
    section_key = section_keys[section_num - 1]
    grouped[section_key].append(new_q)

    with open(QUESTIONS_FILE, "w") as f:
        json.dump(grouped, f, indent=2)

        push_to_github()

    return jsonify({"status": "success"})
if __name__ == "__main__":
    os.makedirs("History", exist_ok=True)
    app.run(debug=True)
